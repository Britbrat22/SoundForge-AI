<script>
/* ===============================
   CORE AUDIO ENGINE (FIXED)
================================ */

let audioContext;
let originalAudioBuffer;
let editedAudioBuffer;
let playbackSource = null;

let selection = { start: 0, end: 0 };
let undoStack = [];
const UNDO_LIMIT = 20;

/* ===============================
   INIT
================================ */

async function initAudioSystem() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
}

/* ===============================
   UNDO SYSTEM
================================ */

function pushUndo() {
  undoStack.push(cloneBuffer(editedAudioBuffer));
  if (undoStack.length > UNDO_LIMIT) undoStack.shift();
}

function undoLastEdit() {
  if (!undoStack.length) return alert("Nothing to undo");
  editedAudioBuffer = undoStack.pop();
  displayWaveform(editedAudioBuffer);
}

/* ===============================
   BUFFER HELPERS
================================ */

function cloneBuffer(buffer) {
  const b = audioContext.createBuffer(
    buffer.numberOfChannels,
    buffer.length,
    buffer.sampleRate
  );
  for (let c = 0; c < buffer.numberOfChannels; c++) {
    b.getChannelData(c).set(buffer.getChannelData(c));
  }
  return b;
}

function extractSelection(buffer, start, end) {
  const sr = buffer.sampleRate;
  const s = Math.floor(start * sr);
  const e = Math.floor(end * sr);
  const len = Math.max(0, e - s);

  const out = audioContext.createBuffer(
    buffer.numberOfChannels,
    len,
    sr
  );

  for (let c = 0; c < buffer.numberOfChannels; c++) {
    out.getChannelData(c).set(
      buffer.getChannelData(c).slice(s, e)
    );
  }
  return out;
}

/* REAL replace (rebuilds buffer correctly) */
function replaceSelection(buffer, insert, start, end) {
  const sr = buffer.sampleRate;
  const s = Math.floor(start * sr);
  const e = Math.floor(end * sr);

  const newLen = buffer.length - (e - s) + insert.length;
  const out = audioContext.createBuffer(
    buffer.numberOfChannels,
    newLen,
    sr
  );

  for (let c = 0; c < buffer.numberOfChannels; c++) {
    const o = out.getChannelData(c);
    const b = buffer.getChannelData(c);
    const i = insert.getChannelData(c);

    o.set(b.slice(0, s), 0);
    o.set(i, s);
    o.set(b.slice(e), s + i.length);
  }
  return out;
}

/* ===============================
   OFFLINE EFFECT PIPELINE
================================ */

async function processOffline(buffer, buildGraph) {
  const ctx = new OfflineAudioContext(
    buffer.numberOfChannels,
    buffer.length,
    buffer.sampleRate
  );

  const src = ctx.createBufferSource();
  src.buffer = buffer;

  const last = buildGraph(ctx, src);
  last.connect(ctx.destination);
  src.start();

  return await ctx.startRendering();
}

/* ===============================
   EFFECT CHAIN
================================ */

async function applyEffectsChain(buffer, fx) {
  return processOffline(buffer, (ctx, src) => {
    let node = src;

    if (fx.pitch !== 0) {
      src.playbackRate.value = Math.pow(2, fx.pitch / 12);
    }

    if (fx.reverb > 0) {
      const convolver = ctx.createConvolver();
      convolver.buffer = makeImpulse(ctx, fx.reverb);
      node.connect(convolver);
      node = convolver;
    }

    if (fx.echo > 0) {
      const delay = ctx.createDelay();
      delay.delayTime.value = 0.25;
      const fb = ctx.createGain();
      fb.gain.value = fx.echo * 0.4;
      delay.connect(fb);
      fb.connect(delay);
      node.connect(delay);
      node = delay;
    }

    return node;
  });
}

function makeImpulse(ctx, amt) {
  const len = ctx.sampleRate * 2;
  const buf = ctx.createBuffer(2, len, ctx.sampleRate);
  for (let c = 0; c < 2; c++) {
    const d = buf.getChannelData(c);
    for (let i = 0; i < len; i++) {
      d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2) * amt;
    }
  }
  return buf;
}

/* ===============================
   EFFECT BUTTON
================================ */

async function applySelectedEffects() {
  if (selection.start === selection.end) return alert("Select audio first");

  pushUndo();

  const sel = extractSelection(
    editedAudioBuffer,
    selection.start,
    selection.end
  );

  const processed = await applyEffectsChain(sel, {
    reverb: document.getElementById("reverbAmount").value / 100,
    echo: document.getElementById("echoAmount").value / 100,
    pitch: parseFloat(document.getElementById("pitchShift").value)
  });

  editedAudioBuffer = replaceSelection(
    editedAudioBuffer,
    processed,
    selection.start,
    selection.end
  );

  displayWaveform(editedAudioBuffer);
}

/* ===============================
   DELETE / FADE
================================ */

function deleteSelection() {
  if (selection.start === selection.end) return;
  pushUndo();

  editedAudioBuffer = replaceSelection(
    editedAudioBuffer,
    audioContext.createBuffer(
      editedAudioBuffer.numberOfChannels,
      0,
      editedAudioBuffer.sampleRate
    ),
    selection.start,
    selection.end
  );
  displayWaveform(editedAudioBuffer);
}

function fade(type) {
  pushUndo();
  const sr = editedAudioBuffer.sampleRate;
  const s = Math.floor(selection.start * sr);
  const e = Math.floor(selection.end * sr);
  const len = e - s;

  for (let c = 0; c < editedAudioBuffer.numberOfChannels; c++) {
    const d = editedAudioBuffer.getChannelData(c);
    for (let i = 0; i < len; i++) {
      const g = type === "in" ? i / len : 1 - i / len;
      d[s + i] *= g;
    }
  }
  displayWaveform(editedAudioBuffer);
}

function fadeInSelection() { fade("in"); }
function fadeOutSelection() { fade("out"); }

/* ===============================
   PLAYBACK
================================ */

function stopPlayback() {
  if (playbackSource) {
    playbackSource.stop();
    playbackSource = null;
  }
}

function playAll() {
  stopPlayback();
  playbackSource = audioContext.createBufferSource();
  playbackSource.buffer = editedAudioBuffer;
  playbackSource.connect(audioContext.destination);
  playbackSource.start();
}

/* ===============================
   WAV EXPORT (FIXED)
================================ */

function audioBufferToWav(buffer) {
  const numCh = buffer.numberOfChannels;
  const len = buffer.length * numCh * 2;
  const ab = new ArrayBuffer(44 + len);
  const v = new DataView(ab);
  let p = 0;

  function w(s) { for (let i = 0; i < s.length; i++) v.setUint8(p++, s.charCodeAt(i)); }

  w("RIFF"); v.setUint32(p, 36 + len, true); p += 4;
  w("WAVEfmt "); v.setUint32(p, 16, true); p += 4;
  v.setUint16(p, 1, true); p += 2;
  v.setUint16(p, numCh, true); p += 2;
  v.setUint32(p, buffer.sampleRate, true); p += 4;
  v.setUint32(p, buffer.sampleRate * numCh * 2, true); p += 4;
  v.setUint16(p, numCh * 2, true); p += 2;
  v.setUint16(p, 16, true); p += 2;
  w("data"); v.setUint32(p, len, true); p += 4;

  for (let i = 0; i < buffer.length; i++) {
    for (let c = 0; c < numCh; c++) {
      v.setInt16(p, buffer.getChannelData(c)[i] * 0x7fff, true);
      p += 2;
    }
  }
  return new Blob([ab], { type: "audio/wav" });
}

/* ===============================
   LOAD FILE
================================ */

async function handleFileLoad(file) {
  await initAudioSystem();
  const buf = await audioContext.decodeAudioData(await file.arrayBuffer());
  originalAudioBuffer = buf;
  editedAudioBuffer = cloneBuffer(buf);
  displayWaveform(editedAudioBuffer);
}

/* ===============================
   START
================================ */

window.addEventListener("load", initAudioSystem);
</script>
